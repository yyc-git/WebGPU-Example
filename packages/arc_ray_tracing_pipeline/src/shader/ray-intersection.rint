#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#pragma shader_stage(intersect)

// TODO duplicate

// struct RayPayload {
//   vec3 radiance;
//   vec2 target;
// };

struct Instance {
  // /*
  //  because scalar not work(not support float objId; mat4 modelMatrix;),
  //  so all aligned to vec4
  //  */

  // include geometryIndex, materialIndex, localPosition
  // vec4 compressedData;

  float geometryIndex;
  float materialIndex;
  // vec2 localPosition;
  float pad_0;
  float pad_1;
};

struct Geometry {
  vec2 c;
  float w;
  float r;
};

layout(std140, set = 0, binding = 2) buffer SceneInstanceData {
  Instance instances[];
}
sceneInstanceData;

layout(std140, set = 0, binding = 3) buffer SceneGeometryData {
  Geometry geometrys[];
}
sceneGeometryData;

// bool _isIntersectWithRing(vec2 point, Geometry geometry) {
// bool _isIntersectWithRing(vec2 origin, vec2 direction, Geometry geometry) {
bool _isIntersectWithRing(vec3 origin, vec3 direction, Geometry geometry) {
  // TODO change to ring!

  vec2 c = geometry.c;
  float w = geometry.w;
  float r = geometry.r;

  vec2 center = c;
  float radius = r;

  // vec2 oc = origin - center;
  vec3 oc = origin - vec3(center, 0.0);
  float a = dot(direction, direction);
  float b = 2.0 * dot(oc, direction);
  float c1 = dot(oc, oc) - radius * radius;
  float discriminant = b * b - 4 * a * c1;

  return discriminant >= 0;

  // //   var worldPosition = localPosition + c;

  // //   var distanceSquare =
  // //       pow(point.x - worldPosition.x, 2.0) + pow(point.y -
  // //       worldPosition.y, 2.0);

  // vec2 localPosition = c;

  // float distanceSquare =
  //     pow(point.x - localPosition.x, 2.0) + pow(point.y -
  //     localPosition.y, 2.0);

  // return distanceSquare >= pow(r, 2) && distanceSquare <= pow(r + w, 2);
}

void main() {
  // RayPayload ray;
  //   ray.origin    = gl_WorldRayOriginEXT;
  //   ray.direction = gl_WorldRayDirectionEXT;
  // ray.target = gl_ObjectRayDirectionEXT.xy;
  // ray.target = gl_ObjectRayDirectionEXT.xy;

  // vec2 point = ray.target;

  uint instanceIndex = gl_InstanceID;

  Instance instance = sceneInstanceData.instances[instanceIndex];
  uint geometryIndex = uint(instance.geometryIndex);
  Geometry geometry = sceneGeometryData.geometrys[geometryIndex];

  // if (_isIntersectWithRing(point, geometry)) {
  // if (_isIntersectWithRing(gl_WorldRayOriginEXT.xy,
  // gl_WorldRayDirectionEXT.xy,
  // if (_isIntersectWithRing(gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT,
  // if (_isIntersectWithRing(gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT,
  // if (_isIntersectWithRing(gl_ObjectRayOriginEXT.xy,
  if (_isIntersectWithRing(gl_ObjectRayOriginEXT, gl_ObjectRayDirectionEXT,
                           geometry)) {
    /*! should > 0.0 !*/
    float tHit = 0.1;

    uint hitKind = 0;

    reportIntersectionEXT(tHit, hitKind);
  }
}
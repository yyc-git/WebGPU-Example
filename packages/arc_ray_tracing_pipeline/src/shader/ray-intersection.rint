#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#pragma shader_stage(intersect)

// TODO duplicate

// struct RayPayload {
//   vec3 radiance;
//   vec2 target;
// };

struct Instance {
  // /*
  //  because scalar not work(not support float objId; mat4 modelMatrix;),
  //  so all aligned to vec4
  //  */

  // include geometryIndex, materialIndex, localPosition
  // vec4 compressedData;

  float geometryIndex;
  float materialIndex;
  // vec2 localPosition;
  float pad_0;
  float pad_1;
};

struct Geometry {
  vec2 c;
  float w;
  float r;
};

layout(std140, set = 0, binding = 2) buffer SceneInstanceData {
  Instance instances[];
}
sceneInstanceData;

layout(std140, set = 0, binding = 3) buffer SceneGeometryData {
  Geometry geometrys[];
}
sceneGeometryData;

// bool _isIntersectWithRing(vec2 point, Geometry geometry) {
// bool _isIntersectWithRing(vec2 origin, vec2 direction, Geometry geometry) {
bool _isIntersectWithRing(vec3 origin, vec3 direction, Geometry geometry) {
  vec2 c = geometry.c;
  float w = geometry.w;
  float r = geometry.r;

  // vec2 center = c;
  // float radius = r;

  // // vec2 oc = origin - center;
  // vec3 oc = origin - vec3(center, 0.0);
  // float a = dot(direction, direction);
  // float b = 2.0 * dot(oc, direction);
  // float c1 = dot(oc, oc) - radius * radius;
  // float discriminant = b * b - 4 * a * c1;

  // return discriminant >= 0;

  vec3 center = vec3(c, 0.0);

  vec3 u = center - origin;

  float dLen = length(direction);

  vec3 directionProjection = dot(u, direction) * direction / pow(dLen, 2);

  float distance = length(u - directionProjection);

  return distance >= r && distance <= r + w;
}

void main() {
  // RayPayload ray;
  //   ray.origin    = gl_WorldRayOriginEXT;
  //   ray.direction = gl_WorldRayDirectionEXT;
  // ray.target = gl_ObjectRayDirectionEXT.xy;
  // ray.target = gl_ObjectRayDirectionEXT.xy;

  // vec2 point = ray.target;

  uint instanceIndex = gl_InstanceID;

  Instance instance = sceneInstanceData.instances[instanceIndex];
  uint geometryIndex = uint(instance.geometryIndex);
  Geometry geometry = sceneGeometryData.geometrys[geometryIndex];

  // if (_isIntersectWithRing(point, geometry)) {
  // if (_isIntersectWithRing(gl_WorldRayOriginEXT.xy,
  // gl_WorldRayDirectionEXT.xy,
  // if (_isIntersectWithRing(gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT,
  // if (_isIntersectWithRing(gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT,
  // if (_isIntersectWithRing(gl_ObjectRayOriginEXT.xy,
  if (_isIntersectWithRing(gl_ObjectRayOriginEXT, gl_ObjectRayDirectionEXT,
                           geometry)) {
    /*! should > 0.0 !*/
    float tHit = 0.1;

    uint hitKind = 0;

    reportIntersectionEXT(tHit, hitKind);
  }
}